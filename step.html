<!DOCTYPE html>
<canvas width='960' height='500'></canvas>
<script src='https://d3js.org/d3.v4.min.js'></script>
<script src='https://unpkg.com/topojson-client@2'></script>
<script src='https://unpkg.com/topojson-simplify@2'></script>
<script src='https://d3js.org/d3-geo.v1.min.js'></script>
<script src='https://d3js.org/d3-geo-projection.v1.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js'></script>
<script>

// see https://bl.ocks.org/mbostock/7755778

let canvas = d3.select('canvas'),
    context = canvas.node().getContext('2d'),
    width = canvas.property('width'),
    height = canvas.property('height')

let regions,
    countries,
    land

let idx = 1

let minZ = 1, // minimum area threshold for simplification
    transform = d3.geoIdentity().clipExtent([[0, 0], [width, height]]),
    simplify = d3.geoTransform({point: function(x, y, z) { if (z >= minZ) this.stream.point(x, y) }})


context.fillStyle = '#bbb'
context.strokeStyle = '#000'
context.lineJoin = 'round'
context.lineCap = 'round'

let projection = d3.geoMercator()
//  .scale(4)
//  .clipAngle(90)
//  .precision(0.6)
//  .rotate([0, 0, 11.5])

let path = d3.geoPath()
    .projection({stream: (s) => projection.stream(s)}) // simplify.stream(transform.stream(s)) })
    .context(context)

d3.queue()
  .defer(d3.json, 'data/topography.json')
  .await( (error, topo) => {
    if (error) throw error

    topojson.presimplify(topo)
    regions = topojson.feature(topo, topo.objects.regions)
    countries = topojson.mesh(topo, topo.objects.countries, (a,b) => a !== b)
    land = topojson.feature(topo, topo.objects.land)

    let zoom = d3.zoom()
//        .scaleExtent([1 / (1 << 5), 1 << 2])
        .on('zoom', zoomed)

    // An arbitrary scale and center point to set the initial view.
    let scale = (width - 1) / 2 / Math.PI
    let point = projection([-65.936,3.37])

    canvas
      .call(zoom)
      .call(zoom.transform, d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(scale))
//        .translate(-point[0], -point[1]))


    d3.select('body')
      .on('keydown', () => {
        switch(d3.event.keyCode) {
          case 37: idx--; break
          case 39: idx++; break
        }
        console.log(idx)
        canvas.call(zoomed)
      })

  function zoomed(d) {
    console.time('render')
    let t = d3.event.transform
    if(t) {
      minZ = 1 / (t.k * t.k)
      projection.translate([t.x, t.y]).scale(t.k)
      console.log(t)
    }

    context.save()
    context.clearRect(0, 0, width, height)
    context.fillStyle = 'lightgrey'
    context.beginPath()
    path(land)
    context.fill()

    context.strokeStyle = 'white'
    context.lineWidth = 1
    context.beginPath()
    path(countries)
    context.stroke()

    regions.features.filter( (d) => d.id === idx )
      .forEach( (d) => {
        let c = d3.geoCentroid(d)
        let p = path.centroid({ type: 'Point', coordinates: c })
        console.log(idx + ' plot ' + JSON.stringify(d.properties) + ' ' + c)
        console.log(d)
        context.strokeStyle = 'blue'
        context.lineWidth = 5
        context.beginPath()
        context.fillStyle = 'red'
        context.arc(p[0], p[1], 15, 0, 2 * Math.PI)
        context.fill()
        context.beginPath()
        path(d)
        context.stroke()
      })
    context.restore()
    console.timeEnd('render')
  }

})

</script>
